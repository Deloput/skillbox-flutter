# flutter_architecture

Flutter Architecture Project by Kirill Davidov

## Getting Started

Что нужно сделать:

1. Создайте пустой проект, используя принципы Clean Architecture.

2. Создайте фейковый сервис на сервисном слое, зарегистрируйте его в
сервис-локаторе (например, GetIt, но необязательно) и получите его на
бизнес-слое через локатор.

3. Подключите Freezed и создайте доменную модель с помощью этой библиотеки.

4. По желанию, усложнённое. Реализуйте собственный генератор кода
(с использованием build runner или без, неважно).

5. Настройте статический анализатор, подключите dart_code_metrics, проведите
анализ и соберите метрики с собственного кода.


Советы и рекомендации:

1. Изучите принципы Clean Architecture.

The Clean Architecture 
by Robert C. Martin (Uncle Bob)

The Dependency Rule
The concentric circles represent different areas of software. In general, the further in you go,
the higher level the software becomes. The outer circles are mechanisms. The inner circles are 
policies.

The overriding rule that makes this architecture work is The Dependency Rule. This rule says that 
source code dependencies can only point inwards. Nothing in an inner circle can know anything at all
about something in an outer circle. In particular, the name of something declared in an outer circle 
must not be mentioned by the code in the inner circle. That includesthe  functions, classes, 
variables, or any other named software entity.

By the same token, data formats used in an outer circle should not be used by an inner circle, 
especially if those formats are generated by a framework in an outer circle. 
We don’t want anything in an outer circle to impact the inner circles.

SOLID
S - Single Responsibility (one class for one encapsulated responsibility/ functionality)
O - Open/Closed Principle (any class is open for extension, but closed for changes)
L - Liskov's Substitution Principle (if a class can work with object, it also should be able to
work with the object's inheritor)
I - Interface Segregation (each class interface should have a strong connection with a single
method in a class)
D - Dependency Inversion (A class should be independent from an implementation of the
class dependency and can work only with dependency's abstraction. Also abstraction's can not be
dependent from the implementation, only the implementation can be related to abstraction )

The Principles simplification for a Flutter Application Architecture
 - Independency from lib's
 - Independency from UI
 - Abilities to test the App

Data Layer (Repositories, File Storage,DB's, Services)
-> Business Layer / State Management Layer (BLoC. MobX, Redux, other)
-> UI Layer (UI Kit, Pages, Router)

To separate these layers, we can use
- FOLDERS (logical separation)
- PACKAGES (physical separation) 


Dependency Inversion Principle (DIP)
 - top-level modules should not be dependent on low-level modules. Both should use abstracts.
 - Abstracts should not be dependent on details. Abstracts should no be depend  from details
   
DIP Principle 
-> IOC Pattern (Inversion Of Control)
-> Service Locator or Dependency Ingection Executors
-> IOC Container Packages

IOC Containers for Service Locator Executors
- GetIt
- IOC
- Injector
- Kiwi
- Injectible

Dependency Ingection
Class <- Injector -> Service

Dependency Ingection Executors
- Injector

Inherited Widget (UI)
Class <- Provider -> Widget/Widget/...

Inherited Widget Executors
- provider (Remi Rousselet)



2. Сервис из пункта 2 может выполнять любую функцию, это непринципиально для задания.

